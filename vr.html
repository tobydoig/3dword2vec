<!--
	webvr being replaced by webxr
		https://immersive-web.github.io/webxr/
	
	mozilla's webxr for three (template for vr)
		https://mozilla.github.io/three.xr.js/
	
	webxr demo from stewart smith (using controllers - which don't work for me - cool, let's fix)
		https://github.com/moar-tech/spacerocks
	
	Using XBox controller emulated via Playstation 4 conteoller (DS4Windows).
	Moving the camera in 3d/webgl mode works, in VR mode it doesn't. Why?
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.xr.js XR 3dword2vec</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
		body {
			margin: 0px;
			color: #fff;
			font-family: Monospace;
			background-color: #444;
			overflow: hidden;
		}
		
		canvas {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
		}
    </style>
</head>
<body>
    <script src="three.min.js"></script>
    <script src='WebVR.js'></script>
    <script src='GamepadControls.js'></script>
    <script src='HUD.js'></script>
    <script src='Bomb.js'></script>
    <script src='html/keyword-data.js'></script>
    <script>
	
	var COLOR_RED = new THREE.Color(0xff0000);
	var COLOR_GREEN = new THREE.Color(0x00ff00);
	var COLOR_WHITE = new THREE.Color(0xffffff);
	var MAX_XY = 100;
	var POINT_SIZE = MAX_XY / 100;

	const MAX_ROT_RADIANS = (2 * Math.PI) / 360;
	const RADIANS_90_DEGREES = Math.PI / 2;
	const FLY_SPEED = MAX_XY / 50;

	
	var renderer = new THREE.WebGLRenderer( { antialias: false } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.autoClear = false;
	renderer.vr.enabled  = true;
	document.body.appendChild( renderer.domElement );
	document.body.appendChild( WEBVR.createButton( renderer, { frameOfReferenceType: 'eye-level' } ) );
	
	var scene = new THREE.Scene();
	scene.background = new THREE.Color( 0x0 );
	
	var player = new THREE.Group();
	scene.add(player);
	
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 70, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = -1;
	var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, -1);
	player.add(camera);
	
	var crosshair = new THREE.Mesh(
		new THREE.RingBufferGeometry( 0.001, 0.002, 16 ),
		new THREE.MeshBasicMaterial( {
			color: 0xff0000,
			opacity: 0.5,
			transparent: true
		} )
	);
	camera.add(crosshair);
	crosshair.position.z = -0.1;
	
	var arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0));
	camera.add(arrowHelper);
	arrowHelper.position.set(0, 0, -2);
	arrowHelper.visible = false;
	
	var hud = new HUD();
	camera.add(hud.plane);
	hud.plane.position.set(0.0, 0.0, -0.1);
	hud.plane.scale.set(0.13 * ASPECT, 0.13, 1.0);
	
	var positions = new Float32Array(W2VDATA.length * 3);
	var colours = new Float32Array(W2VDATA.length * 3);
	var geometry = new THREE.BufferGeometry();
	var palette = [
		new THREE.Color(0xff0000),
		new THREE.Color(0x00ff00),
		new THREE.Color(0x0000ff),
		new THREE.Color(0xffff00),
		new THREE.Color(0x00ffff),
		new THREE.Color(0xC0C0C0),
		new THREE.Color(0xDAA520),
		new THREE.Color(0x800000),
		new THREE.Color(0x800080),
		new THREE.Color(0xD2691E)
	];
	var points;
	(function() {
		//	first normalise our co-ordinates. they're just a bunch of numbers so first let's find the min and max values.
		let min = W2VDATA[0][1];
		let max = min;
		W2VDATA.forEach((e) => {
			min = Math.min(min, Math.min(Math.min(e[1], e[2]), e[3]));
			max = Math.max(max, Math.max(Math.max(e[1], e[2]), e[3]));
		});
		
		//	and now the actualy co-ordinate we store for each point in the graph will be normalised against this diff
		let diff = max - min;
		
		let ix = 0;
		W2VDATA.forEach((e, i) => {
			let x = e[1];//(e[1] - min) / diff;
			let y = e[2];//(e[2] - min) / diff;
			let z = e[3];//(e[3] - min) / diff;
			let c = palette[e[4]];	// make sure e[4] is < CLUSTERS (in w2v.py)
			
			positions[ix] = x * MAX_XY;
			positions[ix + 1] = y * MAX_XY;
			positions[ix + 2] = z * MAX_XY;
			
			colours[ix] = c.r;
			colours[ix + 1] = c.g;
			colours[ix + 2] = c.b;
			
			ix += 3;
		});
		
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colours, 3 ) );
		geometry.colors = colours;
		geometry.computeBoundingSphere();
		
		//	this is why the rendering is so fast, because we're using points. i did try using 3d cubes but it was very slow to render
		//	and anything beyond 50k cubes and my laptop was upset. so...points is the winner.
		let material = new THREE.PointsMaterial( { size: POINT_SIZE, vertexColors: THREE.VertexColors } );
		points = new THREE.Points( geometry, material );
		scene.add( points );
		
//		geometry.translate(-geometry.boundingSphere.center.x, -geometry.boundingSphere.center.y, -geometry.boundingSphere.center.z);
		
		player.position.set(0, 0, geometry.boundingSphere.radius);
		//player.lookAt(geometry.boundingSphere.center);
		//player.rotateX(Math.PI);
		
	})();
	
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		hud.plane.scale.set(0.13 * camera.aspect, 0.13, 1.0);
		renderer.setSize( window.innerWidth, window.innerHeight );
	}
	window.addEventListener( 'resize', onWindowResize, false );
	
	var gamepad = null;

	window.addEventListener("gamepaddisconnected", function(e) {
		console.log("Gamepad disconnected at index %d", e.gamepad.index);
		gamepad = null;
	});

	window.addEventListener("gamepadconnected", function(e) {
		console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
		e.gamepad.index, e.gamepad.id,
		e.gamepad.buttons.length, e.gamepad.axes.length);
		
		if (!gamepad && e.gamepad.id === '054c-09cc-Wireless Controller') {
			gamepad = new GamepadControls(e.gamepad, { FLY_SPEED: FLY_SPEED, MAX_ROT_RADIANS: MAX_ROT_RADIANS });
		}
	});
	
	const KEY_BOOST = 16;
	window.addEventListener('keydown', (e) => {
		switch (e.key) {
			case 'W':
//				player.translateZ(-FLY_SPEED * KEY_BOOST);
				player.position.add(camera.getWorldDirection().multiplyScalar(FLY_SPEED * KEY_BOOST));
				break;
			case 'w':
//				player.translateZ(-FLY_SPEED * KEY_BOOST);
				player.position.add(camera.getWorldDirection().multiplyScalar(FLY_SPEED));
				break;
			case 'S':
//				player.translateZ(FLY_SPEED * KEY_BOOST);
				player.position.add(camera.getWorldDirection().multiplyScalar(-FLY_SPEED * KEY_BOOST));
				break;
			case 's':
				player.position.add(camera.getWorldDirection().multiplyScalar(-FLY_SPEED));
				break;
			case 'A':
				player.translateX(-FLY_SPEED * KEY_BOOST);
				break;
			case 'a':
				player.translateX(-FLY_SPEED);
				break;
			case 'D':
				player.translateX(FLY_SPEED * KEY_BOOST);
				break;
			case 'd':
				player.translateX(FLY_SPEED);
				break;
		}
	});
	
	
	let rayOrigin = new THREE.Vector3(0, 0, 2);
	let raycaster = new THREE.Raycaster();
	raycaster.params.Points.threshold = 8;

	let myball = new THREE.Mesh(new THREE.SphereBufferGeometry(POINT_SIZE * 5), new THREE.MeshBasicMaterial( { color: 0xffffff }));
	scene.add(myball);
	myball.visible = false;
	
	function render() {
//		points.rotateY(0.001);
		if (gamepad) {
//			if (renderer.vr && renderer.vr.isPresenting()) {
				gamepad.update(player, camera);
//			} else {
//				nonVrModePlayerControls();
//			}
		}
			
		if (myball.visible) {
			myball.getWorldPosition(tempVector3);
			camera.worldToLocal(tempVector3);
			arrowHelper.setDirection(tempVector3.normalize());
			
			if (gamepad && gamepad.buttons[3].pressed) {
				bombs.push(new Bomb(myball.position, 1000, -1));
			}			
		}
		
		raycaster.setFromCamera( rayOrigin, camera );
		var hits = raycaster.intersectObjects( [points] );
		if (hits.length) {
			crosshair.material.color = COLOR_GREEN;
				
			let hit = hits[0];
			let a = hit.object.geometry.getAttribute('position');
			let c = hit.object.geometry.getAttribute('color');
			let txt = W2VDATA[hit.index][0];
			
			if (gamepad) {
				if (gamepad.buttons[2].pressed) {
					c.setXYZ(hit.index, COLOR_WHITE.r, COLOR_WHITE.g, COLOR_WHITE.b);
					c.needsUpdate = true;
					
					myball.position.fromBufferAttribute(a, hit.index);
					myball.hitindex = hit.index;
					myball.visible = true;
					
					myball.getWorldPosition(tempVector3);
					camera.worldToLocal(tempVector3);
					arrowHelper.setDirection(tempVector3.normalize());
					arrowHelper.visible = true;
				}
			}
		} else {
			crosshair.material.color = COLOR_RED;
			
			if (gamepad && gamepad.buttons[2].pressed) {
				myball.visible = false;
				myball.hitindex = 0;
				arrowHelper.visible = false;
			}
		}
		
		let reset = !bombs.length;
		bombs.forEach((b, i) => {
			if (b.update()) {
				bombs.splice(i, 1);
			}
		});
		if (reset && !bombs.length) {
			const col = points.geometry.getAttribute('color');
			
			for (let ix = 0; ix < W2VDATA.length; ix++) {
				col.setXYZ(ix, colours[ix * 3], colours[ix * 3 + 1], colours[ix * 3 + 2]);
			}
			col.needsUpdate = true;
		}
		
		hud.update();
		renderer.render(scene, camera);
	}
	
	var bombs = [];
	
	function bomb(s, r) {
		let ix = W2VDATA.findIndex((e) => { return e[0] === s; });
		
		console.log(s + ' found at ' + ix);
		if (ix < 0) {
			return;
		}
		
		let a = points.geometry.getAttribute('position');
		let t = new THREE.Vector3();
		t.fromBufferAttribute(a, ix);
		
		bombs.push(new Bomb(t, r, ix));
	}
	
	renderer.setAnimationLoop( render );
    </script>
  </body>
</html>
