<!--
	webvr being replaced by webxr
		https://immersive-web.github.io/webxr/
	
	mozilla's webxr for three (template for vr)
		https://mozilla.github.io/three.xr.js/
	
	webxr demo from stewart smith (using controllers - which don't work for me - cool, let's fix)
		https://github.com/moar-tech/spacerocks
	
	Using XBox controller emulated via Playstation 4 conteoller (DS4Windows).
	Moving the camera in 3d/webgl mode works, in VR mode it doesn't. Why?
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.xr.js XR 3dword2vec</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
		body {
			margin: 0px;
			color: #fff;
			font-family: Monospace;
			background-color: #444;
			overflow: hidden;
		}
    </style>
</head>
<body>
    <script src="three.min.js"></script>
    <script src='WebVR.js'></script>
    <script src='html/keyword-data.js'></script>
    <script>
	var clock = new THREE.Clock();

	var COLOR_RED = new THREE.Color(0xff0000);
	var COLOR_GREEN = new THREE.Color(0x00ff00);
	var MAX_XY = 1000;
	var POINT_SIZE = 0.1;

	var renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.vr.enabled  = true;
	document.body.appendChild( renderer.domElement );
	document.body.appendChild( WEBVR.createButton( renderer, { frameOfReferenceType: 'eye-level' } ) );
	
	var scene = new THREE.Scene();
	scene.background = new THREE.Color( 0x0 );
	
	var player = new THREE.Group();
	scene.add(player);
	
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 70, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = -1;
	var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, -1);
	player.add(camera);
	
	var crosshair = new THREE.Mesh(
		new THREE.RingBufferGeometry( 0.001, 0.002, 16 ),
		new THREE.MeshBasicMaterial( {
			color: 0xff0000,
			opacity: 0.5,
			transparent: true
		} )
	);
	camera.add(crosshair);
	crosshair.position.z = -0.1;
	
	var positions = new Float32Array(W2VDATA.length * 3);
	var colours = new Float32Array(W2VDATA.length * 3);
	var geometry = new THREE.BufferGeometry();
	var palette = [
		new THREE.Color(0xff0000),
		new THREE.Color(0x00ff00),
		new THREE.Color(0x0000ff),
		new THREE.Color(0xffff00),
		new THREE.Color(0x00ffff),
		new THREE.Color(0xC0C0C0),
		new THREE.Color(0xDAA520),
		new THREE.Color(0x800000),
		new THREE.Color(0x800080),
		new THREE.Color(0xD2691E)
	];
	var points;
	(function() {
		//	first normalise our co-ordinates. they're just a bunch of numbers so first let's find the min and max values.
		let min = W2VDATA[0][1];
		let max = min;
		W2VDATA.forEach((e) => {
			min = Math.min(min, Math.min(Math.min(e[1], e[2]), e[3]));
			max = Math.max(max, Math.max(Math.max(e[1], e[2]), e[3]));
		});
		
		//	and now the actualy co-ordinate we store for each point in the graph will be normalised against this diff
		let diff = max - min;
		
		let ix = 0;
		W2VDATA.forEach((e, i) => {
			let x = (e[1] - min) / diff;
			let y = (e[2] - min) / diff;
			let z = (e[3] - min) / diff;
			let c = palette[e[4]];	// make sure e[4] is < CLUSTERS (in w2v.py)
			
			positions[ix] = x * MAX_XY;
			positions[ix + 1] = y * MAX_XY;
			positions[ix + 2] = z * MAX_XY;
			
			colours[ix] = c.r;
			colours[ix + 1] = c.g;
			colours[ix + 2] = c.b;
			
			ix += 3;
		});
		
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colours, 3 ) );
		geometry.colors = colours;
		geometry.computeBoundingSphere();
		
		//	this is why the rendering is so fast, because we're using points. i did try using 3d cubes but it was very slow to render
		//	and anything beyond 50k cubes and my laptop was upset. so...points is the winner.
		let material = new THREE.PointsMaterial( { size: POINT_SIZE, vertexColors: THREE.VertexColors } );
		points = new THREE.Points( geometry, material );
		scene.add( points );
		
		geometry.translate(-geometry.boundingSphere.center.x, -geometry.boundingSphere.center.y, -geometry.boundingSphere.center.z);
		
		player.lookAt(geometry.boundingSphere.center);
	})();
	
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}
	window.addEventListener( 'resize', onWindowResize, false );
	
	var gamepad = null;
	var lastAxes = null;

	window.addEventListener("gamepaddisconnected", function(e) {
		console.log("Gamepad disconnected at index %d", e.gamepad.index);
		gamepad = null;
	});

	window.addEventListener("gamepadconnected", function(e) {
		console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
		e.gamepad.index, e.gamepad.id,
		e.gamepad.buttons.length, e.gamepad.axes.length);
		
		if (!gamepad && e.gamepad.id === '054c-09cc-Wireless Controller') {
			gamepad = e.gamepad;
			lastAxes = gamepad.axes.slice();
		}
	});
	
	const KEY_BOOST = 0.1;
	window.addEventListener('keydown', (e) => {
		switch (e.key) {
			case 'w':
				player.translateZ(-FLY_SPEED * KEY_BOOST);
				break;
			case 's':
				player.translateZ(FLY_SPEED * KEY_BOOST);
				break;
			case 'a':
				player.translateX(-FLY_SPEED * KEY_BOOST);
				break;
			case 'd':
				player.translateX(FLY_SPEED * KEY_BOOST);
				break;
		}
	});
	
	let XAxisRotation = new THREE.Vector3(1, 0, 0);
	let YAxisRotation = new THREE.Vector3(0, 1, 0);
	let ZAxisRotation = new THREE.Vector3(0, 0, 1);
	let MAX_ROT_RADIANS = (2 * Math.PI) / 360;
	var FLY_SPEED = 5;
	var labels = {};

	function render() {
		player.rotateX(MAX_ROT_RADIANS * 0.1);
		player.rotateY(MAX_ROT_RADIANS * 0.2);
		if (gamepad) {
			let s = '';
			gamepad.axes.forEach((a, i) => {
				if (Math.abs(a - lastAxes[i]) > 0.1) {
					switch (i) {
						case 0: //	left Horiz
							player.translateX(FLY_SPEED * a);
		//							console.log('left horiz: %d, %d, %d' + crosshair.position.x, crosshair.position.y, crosshair.position.z);
							break;
						case 1: //	left Vert
							player.translateZ(FLY_SPEED * a);
		//							console.log('left vert: %d, %d, %d' + crosshair.position.x, crosshair.position.y, crosshair.position.z);
							break;
						case 2: //	right Horiz
							player.rotateY(-MAX_ROT_RADIANS * a);
		//							console.log('right horiz: %d, %d, %d' + crosshair.position.x, crosshair.position.y, crosshair.position.z);
							break;
						case 5: //	right Vert
							player.rotateX(MAX_ROT_RADIANS * a);
		//							console.log('right vert: %d, %d, %d' + crosshair.position.x, crosshair.position.y, crosshair.position.z);
							break;
						default:
							break;
					}
				}
			});
				
	//			raycaster.setFromCamera( { x: 0, y: 0 }, camera );
	//			var hits = raycaster.intersectObjects( [points] );
	//			if (hits.length) {
	//				crosshair.material.color = COLOR_GREEN;
	//			} else {
	//				crosshair.material.color = COLOR_RED;
	//			}
				
			gamepad.buttons.forEach((b, i) => {
				if (b.pressed) {
					//console.log("pressed " + i);
					switch (i) {
						case 0:	//	square
							break;
						case 1:	//	x
							if (b.pressed) {
								player.translateZ(-FLY_SPEED * 4);
	//								console.log('right vert: %d, %d, %d' + crosshair.position.x, crosshair.position.y, crosshair.position.z);
							}
							break;
						case 2:	//	circle
							if (hits.length) {
								let hit = hits[0];
								let a = hit.object.geometry.getAttribute('position');
								let txt = W2VDATA[hit.index][0];
								console.log(hit.index + ' - ' + txt);
								
								//if (gamepad.buttons[2].pressed) {
									if (!labels.hasOwnProperty(hit.index)) {
										let label = makeTextSprite(txt, {fontstyle: 'white'});
										scene.add(label);
										label.position.fromBufferAttribute(a, hit.index);
										label.translateX(-50);
										label.translateY(300);
										labels[hit.index] = label;
									}
								//}
							}
							break;
						case 3:	//	triangle
							break;
						case 4:	//	left 2
							player.rotateZ(-MAX_ROT_RADIANS);
							break;
						case 5:	//	right 2
							player.rotateZ(MAX_ROT_RADIANS);
							break;
						case 6:	//	left trigger
							break;
						case 7:	//	right trigger
						default:
							break;
					}
				}
			});
		}
		
		renderer.render(scene, camera);
	}
	
	renderer.setAnimationLoop( render );
    </script>
  </body>
</html>
