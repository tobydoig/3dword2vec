<!--
	webvr being replaced by webxr
		https://immersive-web.github.io/webxr/
	
	mozilla's webxr for three (template for vr)
		https://mozilla.github.io/three.xr.js/
	
	webxr demo from stewart smith (using controllers - which don't work for me - cool, let's fix)
		https://github.com/moar-tech/spacerocks
	
	Using XBox controller emulated via Playstation 4 conteoller (DS4Windows).
	Moving the camera in 3d/webgl mode works, in VR mode it doesn't. Why?
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.xr.js XR 3dword2vec</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
		body {
			margin: 0px;
			color: #fff;
			font-family: Monospace;
			background-color: #444;
			overflow: hidden;
		}
		
		canvas {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
		}
    </style>
</head>
<body>
    <script src="three.min.js"></script>
    <script src='WebVR.js'></script>
    <script src='html/keyword-data.js'></script>
    <script>
	
	function Bomb(target, radius, id) {
		const ANIMATION_TIME = 3000;
		const blast = new THREE.Sphere();
		const vec3 = new THREE.Vector3();
		const bodies = [];
		const startTime = performance.now();
		const col = points.geometry.getAttribute('color');
		const edge = radius * 0.25;
		
		blast.set(target, radius);
		
		for (let ix = 0; ix < W2VDATA.length; ix++) {
			vec3.set(positions[ix * 3], positions[ix * 3 + 1], positions[ix * 3 + 2]);
			dist = blast.distanceToPoint(vec3);
			if (dist < 0) {
				bodies.push(ix);
			}
			col.setXYZ(ix, 0, 0, 0);
		}
		col.needsUpdate = true;
		console.log('found ' + bodies.length);
		
		this.update = function() {
			let delta = performance.now() - startTime;
			let maxColor = Math.min(delta / ANIMATION_TIME, 1.0);
			blast.radius = (radius + edge) * maxColor;
			
			bodies.forEach((ix) => {
				vec3.set(positions[ix * 3], positions[ix * 3 + 1], positions[ix * 3 + 2])
				let dist = blast.distanceToPoint(vec3);
				
				let r = 0;
				let g = 0;
				
				if (dist > 0 && dist < edge) {
					//	leading edge
					r = (edge - dist) / edge;
					g = 0;
				} else if (dist < 0 && dist >= -edge) {
					//	trailing edge
					r = (edge + dist) / edge;
					g = 0.0;
				}
				
				dist = radius + dist;
				dist = dist / radius;
				
				if (ix === id) {
					console.log('dist = ' + dist + ', maxColor=' + maxColor);
				}
				col.setXYZ(ix, r, g, 0);
			});
			col.needsUpdate = true;
			
			return delta >= ANIMATION_TIME;
		};
	}
	
	function HUD() {
		const FONT_SIZE = 12;
		const MAX_TEXT_LINES = 10;
		const text = [];
		
		let lastNow = performance.now();
		let lastFps = 0;
		let duration = 0;
		let fps = 0;
		
		let canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 512;
        let context = canvas.getContext('2d');
        let texture = new THREE.Texture(canvas);
        let material = new THREE.MeshBasicMaterial({ map: texture, depthTest: false, transparent: true });
        let geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
        this.plane = new THREE.Mesh(geometry, material);
		
		const labels = {};
		const labelsList = [];
		const MAX_LABELS = 20;
		this.addLabel = function(ix) {
			if (!labels.hasOwnProperty(ix)) {
				if (labelsList.length >= MAX_LABELS) {
					let old = labelsList.splice(0, 1);
					delete labels[old];
				}
				labels[ix] = true;
				labelsList.push(ix);
				appendText(W2VDATA[ix][0]);
			}
		};
		
		function updateFps() {
			let now = performance.now();
			duration += (now - lastNow);
			lastNow = now;
			
			++fps;
			if (duration > 1000) {
				duration = 0;
				lastFps = fps;
				fps = 0;
				
				return true;
			}
			
			return false;
		}
		
		this.update = function() {
			updateFps();
			redraw();
		};
		
		let frustum = new THREE.Frustum();
		let m4 = new THREE.Matrix4();
		let v3 = new THREE.Vector3();
		
		function redraw() {
			context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = "rgba(0, 0, 80, 0.3)";
			context.fillRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = "#ff0000";
			context.strokeRect(0, 0, canvas.width, canvas.height);
			
			context.font = "12pt Calibri";
            context.fillStyle = "#aaaaaa";
            context.fillStyle = 'rgba(200, 200, 200, 1)';
			text.forEach((t, i) => {
				context.fillText(t, 1, ++i * FONT_SIZE);
			});
			context.fillText(lastFps, 990, FONT_SIZE);
			
			if (labelsList.length) {
				frustum.setFromMatrix( m4.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse ) );
				labelsList.forEach((ix) => {
					v3.set(positions[ix * 3], positions[ix * 3 + 1], positions[ix * 3 + 2]);
					if (frustum.containsPoint(v3)) {
						let v2 = v3.project(camera);
						v2.x = (v2.x + 1) / 2 * canvas.width;
						v2.y = -(v2.y - 1) / 2 * canvas.height;
						context.fillText(W2VDATA[ix][0], v2.x, v2.y);
					}
				});
			}
			
			texture.needsUpdate = true;
		};
		
		function appendText(s) {
			if (text.length) {
				if (text[text.length - 1] === s) {
					return;
				}
			}
			text.push(s);
			if (text.length > MAX_TEXT_LINES) {
				text.splice(0, 1);
			}
		};
	}
	
	var COLOR_RED = new THREE.Color(0xff0000);
	var COLOR_GREEN = new THREE.Color(0x00ff00);
	var COLOR_WHITE = new THREE.Color(0xffffff);
	var MAX_XY = 100;
	var POINT_SIZE = MAX_XY / 100;

	var renderer = new THREE.WebGLRenderer( { antialias: false } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.autoClear = false;
	renderer.vr.enabled  = true;
	document.body.appendChild( renderer.domElement );
	document.body.appendChild( WEBVR.createButton( renderer, { frameOfReferenceType: 'eye-level' } ) );
	
	var scene = new THREE.Scene();
	scene.background = new THREE.Color( 0x0 );
	
	var player = new THREE.Group();
	scene.add(player);
	
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 70, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = -1;
	var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, -1);
	player.add(camera);
	
	var crosshair = new THREE.Mesh(
		new THREE.RingBufferGeometry( 0.001, 0.002, 16 ),
		new THREE.MeshBasicMaterial( {
			color: 0xff0000,
			opacity: 0.5,
			transparent: true
		} )
	);
	camera.add(crosshair);
	crosshair.position.z = -0.1;
	
	var arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0));
	camera.add(arrowHelper);
	arrowHelper.position.set(0, 0, -2);
	arrowHelper.visible = false;
	
	var hud = new HUD();
	camera.add(hud.plane);
	hud.plane.position.set(0.0, 0.0, -2.0);
	hud.plane.scale.set(4.9, 2.8, 1.0);
	
	var positions = new Float32Array(W2VDATA.length * 3);
	var colours = new Float32Array(W2VDATA.length * 3);
	var geometry = new THREE.BufferGeometry();
	var palette = [
		new THREE.Color(0xff0000),
		new THREE.Color(0x00ff00),
		new THREE.Color(0x0000ff),
		new THREE.Color(0xffff00),
		new THREE.Color(0x00ffff),
		new THREE.Color(0xC0C0C0),
		new THREE.Color(0xDAA520),
		new THREE.Color(0x800000),
		new THREE.Color(0x800080),
		new THREE.Color(0xD2691E)
	];
	var points;
	(function() {
		//	first normalise our co-ordinates. they're just a bunch of numbers so first let's find the min and max values.
		let min = W2VDATA[0][1];
		let max = min;
		W2VDATA.forEach((e) => {
			min = Math.min(min, Math.min(Math.min(e[1], e[2]), e[3]));
			max = Math.max(max, Math.max(Math.max(e[1], e[2]), e[3]));
		});
		
		//	and now the actualy co-ordinate we store for each point in the graph will be normalised against this diff
		let diff = max - min;
		
		let ix = 0;
		W2VDATA.forEach((e, i) => {
			let x = e[1];//(e[1] - min) / diff;
			let y = e[2];//(e[2] - min) / diff;
			let z = e[3];//(e[3] - min) / diff;
			let c = palette[e[4]];	// make sure e[4] is < CLUSTERS (in w2v.py)
			
			positions[ix] = x * MAX_XY;
			positions[ix + 1] = y * MAX_XY;
			positions[ix + 2] = z * MAX_XY;
			
			colours[ix] = c.r;
			colours[ix + 1] = c.g;
			colours[ix + 2] = c.b;
			
			ix += 3;
		});
		
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colours, 3 ) );
		geometry.colors = colours;
		geometry.computeBoundingSphere();
		
		//	this is why the rendering is so fast, because we're using points. i did try using 3d cubes but it was very slow to render
		//	and anything beyond 50k cubes and my laptop was upset. so...points is the winner.
		let material = new THREE.PointsMaterial( { size: POINT_SIZE, vertexColors: THREE.VertexColors } );
		points = new THREE.Points( geometry, material );
		scene.add( points );
		
//		geometry.translate(-geometry.boundingSphere.center.x, -geometry.boundingSphere.center.y, -geometry.boundingSphere.center.z);
		
		player.position.set(0, 0, geometry.boundingSphere.radius);
		//player.lookAt(geometry.boundingSphere.center);
		//player.rotateX(Math.PI);
		
	})();
	
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}
	window.addEventListener( 'resize', onWindowResize, false );
	
	var gamepad = null;
	var lastAxes = null;

	window.addEventListener("gamepaddisconnected", function(e) {
		console.log("Gamepad disconnected at index %d", e.gamepad.index);
		gamepad = null;
	});

	window.addEventListener("gamepadconnected", function(e) {
		console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
		e.gamepad.index, e.gamepad.id,
		e.gamepad.buttons.length, e.gamepad.axes.length);
		
		if (!gamepad && e.gamepad.id === '054c-09cc-Wireless Controller') {
			gamepad = e.gamepad;
			lastAxes = gamepad.axes.slice();
		}
	});
	
	const KEY_BOOST = 1;
	window.addEventListener('keydown', (e) => {
		switch (e.key) {
			case 'w':
//				player.translateZ(-FLY_SPEED * KEY_BOOST);
				player.position.add(camera.getWorldDirection().multiplyScalar(FLY_SPEED * KEY_BOOST));
				break;
			case 's':
//				player.translateZ(FLY_SPEED * KEY_BOOST);
				player.position.add(camera.getWorldDirection().multiplyScalar(-FLY_SPEED * KEY_BOOST));
				break;
			case 'a':
				player.translateX(-FLY_SPEED * KEY_BOOST);
				break;
			case 'd':
				player.translateX(FLY_SPEED * KEY_BOOST);
				break;
		}
	});
	
	let XAxisRotation = new THREE.Vector3(1, 0, 0);
	let YAxisRotation = new THREE.Vector3(0, 1, 0);
	let ZAxisRotation = new THREE.Vector3(0, 0, 1);
	let MAX_ROT_RADIANS = (2 * Math.PI) / 720;
	let RADIANS_90_DEGREES = Math.PI / 2;
	var FLY_SPEED = MAX_XY / 50;
	var labels = {};
	let tempQuaternion = new THREE.Quaternion();
	let tempVector3 = new THREE.Vector3();
	let tempMatrix4 = new THREE.Matrix4();
	let X90AxisQuaternion = new THREE.Quaternion();
	X90AxisQuaternion.setFromAxisAngle(XAxisRotation, RADIANS_90_DEGREES);
	let Y90AxisQuaternion = new THREE.Quaternion();
	Y90AxisQuaternion.setFromAxisAngle(YAxisRotation, RADIANS_90_DEGREES);
	let Z90AxisQuaternion = new THREE.Quaternion();
	Z90AxisQuaternion.setFromAxisAngle(ZAxisRotation, RADIANS_90_DEGREES);
	
	function vrModePlayerControls() {
		let s = '';
		gamepad.axes.forEach((a, i) => {
			if (Math.abs(a - lastAxes[i]) > 0.1) {
				switch (i) {
					case 0: //	left Horiz
						player.translateX(FLY_SPEED * a * (gamepad.buttons[1].pressed ? 2 : 1));
						break;
					case 1: //	left Vert
						player.translateZ(FLY_SPEED * a * (gamepad.buttons[1].pressed ? 2 : 1));
						break;
					case 2: //	right Horiz
						camera.getWorldQuaternion(tempQuaternion);
						tempQuaternion.multiply(Y90AxisQuaternion);
						tempMatrix4.makeRotationFromQuaternion(tempQuaternion);
						tempVector3.setFromMatrixColumn(tempMatrix4, 1);
						player.rotateOnWorldAxis(tempVector3, -MAX_ROT_RADIANS * a);
						break;
					case 5: //	right Vert
						camera.getWorldQuaternion(tempQuaternion);
						tempQuaternion.multiply(Z90AxisQuaternion);
						tempMatrix4.makeRotationFromQuaternion(tempQuaternion);
						tempVector3.setFromMatrixColumn(tempMatrix4, 1);
						player.rotateOnWorldAxis(tempVector3, -MAX_ROT_RADIANS * a);
						break;
					default:
						break;
				}
			}
		});
			
		gamepad.buttons.forEach((b, i) => {
			if (b.pressed) {
				switch (i) {
					case 0:	//	square
						break;
					case 1:	//	x
						//if (b.pressed) {
						//	camera.getWorldDirection(tempVector3);
						//	player.position.add(tempVector3.multiplyScalar(FLY_SPEED * 2));
						//}
						break;
					case 2:	//	circle
						break;
					case 3:	//	triangle
						break;
					case 4:	//	left 2
						camera.getWorldQuaternion(tempQuaternion);
						tempQuaternion.multiply(X90AxisQuaternion);
						tempMatrix4.makeRotationFromQuaternion(tempQuaternion);
						tempVector3.setFromMatrixColumn(tempMatrix4, 1);
						player.rotateOnWorldAxis(tempVector3, -MAX_ROT_RADIANS);
						break;
					case 5:	//	right 2
						camera.getWorldQuaternion(tempQuaternion);
						tempQuaternion.multiply(X90AxisQuaternion);
						tempMatrix4.makeRotationFromQuaternion(tempQuaternion);
						tempVector3.setFromMatrixColumn(tempMatrix4, 1);
						player.rotateOnWorldAxis(tempVector3, MAX_ROT_RADIANS);
						break;
					case 6:	//	left trigger
						break;
					case 7:	//	right trigger
					default:
						break;
				}
			}
		});
	}
	
	function nonVrModePlayerControls() {
		let s = '';
		gamepad.axes.forEach((a, i) => {
			if (Math.abs(a - lastAxes[i]) > 0.1) {
				switch (i) {
					case 0: //	left Horiz
//							camera.getWorldDirection(tempVector3);
//				player.position.add(tempVector3.applyAxisAngle(YAxisRotation, -RADIANS_90_DEGREES).multiplyScalar(FLY_SPEED * a));
						player.translateX(FLY_SPEED * a * (gamepad.buttons[1].pressed ? 2 : 1));
	//							console.log('left horiz: %d, %d, %d' + crosshair.position.x, crosshair.position.y, crosshair.position.z);
						break;
					case 1: //	left Vert
//							camera.getWorldDirection(tempVector3);
//				player.position.sub(tempVector3.multiplyScalar(FLY_SPEED * a));
						player.translateZ(FLY_SPEED * a * (gamepad.buttons[1].pressed ? 2 : 1));
	//							console.log('left vert: %d, %d, %d' + crosshair.position.x, crosshair.position.y, crosshair.position.z);
						break;
					case 2: //	right Horiz
							player.rotateY(-MAX_ROT_RADIANS * a);
						break;
					case 5: //	right Vert
							player.rotateX(MAX_ROT_RADIANS * a);
						break;
					default:
						break;
				}
			}
		});
			
		gamepad.buttons.forEach((b, i) => {
			if (b.pressed) {
				switch (i) {
					case 0:	//	square
						break;
					case 1:	//	x
//						if (b.pressed) {
//								player.translateZ(-FLY_SPEED * 4);
//						}
						break;
					case 2:	//	circle
						break;
					case 3:	//	triangle
						break;
					case 4:	//	left 2
//							camera.getWorldDirection(tempVector3);
//							player.rotateOnWorldAxis(tempVector3, MAX_ROT_RADIANS);
							player.rotateZ(-MAX_ROT_RADIANS);
						break;
					case 5:	//	right 2
//							camera.getWorldDirection(tempVector3);
//							player.rotateOnWorldAxis(tempVector3, -MAX_ROT_RADIANS);
							player.rotateZ(MAX_ROT_RADIANS);
						break;
					case 6:	//	left trigger
						break;
					case 7:	//	right trigger
					default:
						break;
				}
			}
		});
	}
	
	let rayOrigin = new THREE.Vector3(0, 0, 2);
	let raycaster = new THREE.Raycaster();
	raycaster.params.Points.threshold = 8;

	let myball = new THREE.Mesh(new THREE.SphereBufferGeometry(POINT_SIZE * 5), new THREE.MeshBasicMaterial( { color: 0xffffff }));
	scene.add(myball);
	myball.visible = false;
	
	function render() {
//		points.rotateY(0.001);
		if (gamepad) {
			if (renderer.vr && renderer.vr.isPresenting()) {
				vrModePlayerControls();
			} else {
				nonVrModePlayerControls();
			}
		}
			
		if (myball.visible) {
			myball.getWorldPosition(tempVector3);
			camera.worldToLocal(tempVector3);
			arrowHelper.setDirection(tempVector3.normalize());
			
			if (gamepad && gamepad.buttons[3].pressed) {
				bombs.push(new Bomb(myball.position, 1000, -1));
			}			
		}
		
		raycaster.setFromCamera( rayOrigin, camera );
		var hits = raycaster.intersectObjects( [points] );
		if (hits.length) {
			crosshair.material.color = COLOR_GREEN;
				
			let hit = hits[0];
			let a = hit.object.geometry.getAttribute('position');
			let c = hit.object.geometry.getAttribute('color');
			let txt = W2VDATA[hit.index][0];
			
			hud.addLabel(hit.index);
			
			if (gamepad) {
				if (gamepad.buttons[2].pressed) {
					c.setXYZ(hit.index, COLOR_WHITE.r, COLOR_WHITE.g, COLOR_WHITE.b);
					c.needsUpdate = true;
					
					myball.position.fromBufferAttribute(a, hit.index);
					myball.hitindex = hit.index;
					myball.visible = true;
					
					myball.getWorldPosition(tempVector3);
					camera.worldToLocal(tempVector3);
					arrowHelper.setDirection(tempVector3.normalize());
					arrowHelper.visible = true;
				}
			}
		} else {
			crosshair.material.color = COLOR_RED;
			
			if (gamepad && gamepad.buttons[2].pressed) {
				myball.visible = false;
				myball.hitindex = 0;
				arrowHelper.visible = false;
			}
		}
		
		let reset = !bombs.length;
		bombs.forEach((b, i) => {
			if (b.update()) {
				bombs.splice(i, 1);
			}
		});
		if (reset && !bombs.length) {
			const col = points.geometry.getAttribute('color');
			
			for (let ix = 0; ix < W2VDATA.length; ix++) {
				col.setXYZ(ix, colours[ix * 3], colours[ix * 3 + 1], colours[ix * 3 + 2]);
			}
			col.needsUpdate = true;
		}
		
		hud.update();
		renderer.render(scene, camera);
	}
	
	var bombs = [];
	
	function bomb(s, r) {
		let ix = W2VDATA.findIndex((e) => { return e[0] === s; });
		
		console.log(s + ' found at ' + ix);
		if (ix < 0) {
			return;
		}
		
		let a = points.geometry.getAttribute('position');
		let t = new THREE.Vector3();
		t.fromBufferAttribute(a, ix);
		
		bombs.push(new Bomb(t, r, ix));
	}
	
	renderer.setAnimationLoop( render );
    </script>
  </body>
</html>
