<html>
<head>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
	<script src="coords-umap.txt"></script>
	<script src="three.min.js"></script>
	<script src="OrbitControls.js"></script>
	<script src="Lut.js"></script>
</head>
<body>
<div id="ThreeJS" style="z-index: 1; position: absolute; left:0px; top:0px"></div>
<script>
	var container, scene, camera, renderer, controls;
	// SCENE
	scene = new THREE.Scene();
	var raycaster = new THREE.Raycaster();
	raycaster.params.Points.threshold = 128;
	
	var mouse = new THREE.Vector2();
	var lastSelected = undefined;

	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	
	//	draw a red/green/blue grid to show x/y/z axis
	var DRAW_GRID = false;
	
	// how many to spread our the datapoints by which will also impact how big the points are in the graph.
	// if you pick a MAX_XY too small and it either crashes or looks very blocky/rubbish.
	// if you pick something bigger then you will also need to increase POINT_SIZE
	var MAX_XY = 100000;
	var POINT_SIZE = 128;
	
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, -1);
	scene.add(camera);
	
	// the coords-map-large.txt file defines W2VDATA whiich contains our keywords and their co-ordinates.
	var geometry = new THREE.BufferGeometry();
	var points;
	var positions = new Float32Array(W2VDATA.length * 3);
	var colours = new Float32Array(W2VDATA.length * 3);
	
	//	create a lookup table to convert from our group number (generated by the k-means step) and a suitable colour.
	//  the second param to THREE.Lut() should be <= CLUSTERS in w2v.py
	var lut = new THREE.Lut( "rainbow", 20 );
	lut.setMin(0);
	lut.setMax(19);
	
	//	instead of using the lookup table above we can also use the colours below. this is how i started off, the lut above
	//	was something i added later. not convinced about it though hence not removing either code yet.
	var palette = [
		new THREE.Color(0xff0000),
		new THREE.Color(0x00ff00),
		new THREE.Color(0x0000ff),
		new THREE.Color(0xffff00),
		new THREE.Color(0x00ffff),
		new THREE.Color(0xC0C0C0),
		new THREE.Color(0xDAA520),
		new THREE.Color(0x800000),
		new THREE.Color(0x800080),
		new THREE.Color(0xD2691E)
	];
	
	(function() {
		//	first normalise our co-ordinates. they're just a bunch of numbers so first let's find the min and max values.
		let min = 999;
		let max = -999;
		
		W2VDATA.forEach((e) => {
			min = Math.min(min, Math.min(Math.min(e[1], e[2]), e[3]));
			max = Math.max(max, Math.max(Math.max(e[1], e[2]), e[3]));
		});
		
		//	and now the actualy co-ordinate we store for each point in the graph will be normalised against this diff
		let diff = max - min;
		
		let ix = 0;
		W2VDATA.forEach((e, i) => {
			let x = (e[1] - min) / diff;
			let y = (e[2] - min) / diff;
			let z = (e[3] - min) / diff;
			let c = palette[e[4]];	// make sure e[4] is < CLUSTERS (in w2v.py)
			//let c = lut.getColor(e[4]);
			
			positions[ix] = x * MAX_XY;
			positions[ix + 1] = y * MAX_XY;
			positions[ix + 2] = z * MAX_XY;
			
			colours[ix] = c.r;
			colours[ix + 1] = c.g;
			colours[ix + 2] = c.b;
			
			ix += 3;
		});
		
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colours, 3 ) );
		geometry.colors = colours;
		geometry.computeBoundingSphere();
		
		geometry.translate(-geometry.boundingSphere.center.x, -geometry.boundingSphere.center.y, -geometry.boundingSphere.center.z);
		
		//	this is why the rendering is so fast, because we're using points. i did try using 3d cubes but it was very slow to render
		//	and anything beyond 50k cubes and my laptop was upset. so...points is the winner.
		let material = new THREE.PointsMaterial( { size: POINT_SIZE, vertexColors: THREE.VertexColors } );
		points = new THREE.Points( geometry, material );
		scene.add( points );
		
		camera.position.set(0, geometry.boundingSphere.radius, geometry.boundingSphere.radius);
		camera.lookAt(geometry.boundingSphere.center);
	})();
	
	renderer = new THREE.WebGLRenderer( {antialias:false} );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	window.addEventListener( 'resize', () => {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}, false );	
	
	//	if you enable the grid you'll notice the origin is the center of the sphere that contains the points, not the weighted
	//	centre of the points. (ie. it looks off)
	DRAW_GRID && (function() {
		var gridXZ = new THREE.GridHelper(MAX_XY, 10, new THREE.Color(0x006600), new THREE.Color(0x006600));
		gridXZ.position.set( MAX_XY / 2, 0, MAX_XY / 2 );
		scene.add(gridXZ);
		
		var gridXY = new THREE.GridHelper(MAX_XY, 10, new THREE.Color(0x000066), new THREE.Color(0x000066));
		gridXY.position.set( MAX_XY / 2, MAX_XY / 2, 0 );
		gridXY.rotation.x = Math.PI / 2;
		scene.add(gridXY);

		var gridYZ = new THREE.GridHelper(MAX_XY, 10, new THREE.Color(0x660000), new THREE.Color(0x660000));
		gridYZ.position.set( 0, MAX_XY / 2, MAX_XY / 2 );
		gridYZ.rotation.z = Math.PI / 2;
		scene.add(gridYZ);
	})();
	
	document.addEventListener('keypress', (evt) => {
		if (evt.key === 'w') {
			camera.translateZ(-MAX_XY / 1);
			render();		
		update();
		} else if (evt.key === 's') {
			camera.translateZ(MAX_XY / 1);
			render();		
		update();
		} else if (evt.key === 'a') {
			camera.translateX(-MAX_XY / 1);
			render();		
		update();
		} else if (evt.key === 'd') {
			camera.translateX(MAX_XY / 1);
			render();		
		update();
		}
	});
	
	//	we track what's under the mouse and put a white sphere over that data point (keyword).
	//	if you click then the sphere sticks, if you click empty space then the sphere unsticks.
	//	if the sphere isn't sticky then the keyword is printed to the developer console.
	var myBall;
	var lastSelected = -1;
	var picked = false;

	(function() {
		let geom = new THREE.SphereBufferGeometry(POINT_SIZE);
		let mat = new THREE.MeshBasicMaterial( { color: 0xffffff });
		myBall = new THREE.Mesh(geom, mat);
		
		myBall.position.set(positions[0], positions[1], positions[2]);
		
		scene.add(myBall);
	})();
	
	function onMouseDown(event) {
		event.preventDefault();
		
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		
		raycaster.setFromCamera( mouse, camera );
		
		let hits = raycaster.intersectObject(points);
		if (hits.length) {
			let hit = hits[0];
			let ix = hit.index * 3;
			let a = hit.object.geometry.getAttribute('position');
			myBall.position.set(a.array[ix], a.array[ix + 1], a.array[ix + 2]);
			lastSelected = hit.index;
			
			console.log(W2VDATA[hit.index][0]);
			
			picked = true;
		} else {
			myBall.position.set(camera.position.x, camera.position.y, camera.position.z);
			lastSelected = -1;
			picked = false;
		}
	}
	
	function onMouseMove( event ) {
		// calculate mouse position in normalized device coordinates
		// (-1 to +1) for both components

		if (event.buttons) return;
		
		event.preventDefault();
		
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		
		if (picked) return;
		
		raycaster.setFromCamera( mouse, camera );
		
		let hits = raycaster.intersectObject(points);
		if (hits.length) {
			let hit = hits[0];
			
			if (lastSelected == hit.index) return;
			
			let ix = hit.index * 3;
			
			//	if you want to change the colour of the data point under the mouse then do the following
			//let a = hit.object.geometry.getAttribute('color');
			//a.set(plopsy, ix);
			//a.needsUpdate = true;
			
			let a = hit.object.geometry.getAttribute('position');
			myBall.position.set(a.array[ix], a.array[ix + 1], a.array[ix + 2]);
			lastSelected = hit.index;
			
			console.log(W2VDATA[hit.index][0]);
		} else {
			myBall.position.set(camera.position.x, camera.position.y, camera.position.z);
			lastSelected = -1;
		}
	}
	
	function animate() 
	{
		requestAnimationFrame( animate );
		render();		
		update();
	}

	function update()
	{
		controls.update();
	}

	function render() 
	{
		renderer.render( scene, camera );
	}
	
	animate();
	window.addEventListener( 'mousedown', onMouseDown, false );
	window.addEventListener( 'mousemove', onMouseMove, false );

</script>
</body>
</html>
