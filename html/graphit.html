<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>3d Word2Vwc</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="css/bootstrap.min.css">

		<style>
		#ThreeJS {
			width: 100%;
			height: 100%;
		}
		canvas { width: 100%; height: 100%; }
		.textlayer {
			width: 200px;
			height: 420px;
			position: absolute;
			left: 10px;
			bottom: 10px;
			margin: 0;
			background-color: transparent;
			z-index: 20;
			border: white;
			border-style: double
		}
		.textglass {
			position: absolute;
			top: 0;
			left: 0;
			width:100%;
			height:100%;
			background-color: #005;
			opacity: 0.75;
			z-index: 21;
		}
		.textitems {
			position: absolute;
			top: 0;
			left: 0;
			width:100%;
			height:100%;
			line-height: 1.25;
			background-color: transparent;
			color: #fff;
			z-index: 22;
		}
		.text-label {
		  color: #fff;
		  font-family: "Fira Mono", Monaco, "Andale Mono", "Lucida Console", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace;
		  margin: -5px 0 0 15px;
		  pointer-events:none;
		}
		.seedouter {
			position: absolute;
			width: 100%;
			top: 10px;
			background-color: transparent;
			z-index: 12;
		}
		.seedlayer {
			width: 50%;
			margin: 0 auto;
			background-color: pink;
			text-align: center;
		}
		.pill {
			border: 1px solid white;
		}
		.closebox {
			padding: 8;
			margin: 0;
			border: 1px solid red
		}
	</style>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="js/jquery-3.3.1.slim.min.js"></script>
    <script src="js/popper.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
	<script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/Lut.js"></script>
	<script src="keyword-data.js"></script>
	<script>
		function addSeed() {
			var seedElem = document.querySelector('.seedlayer input[type=text]');
			var seed = seedElem.value.trim();
			var idx = W2VDATA.findIndex((e) => { return e[0] === seed;});
			if (idx >= 0) {
				console.log('found at ' + idx);
				addTextPoint(idx);
				var pill = document.createElement('span');
				pill.className = 'badge badge-pill badge-info';
				pill.appendChild(document.createTextNode(seed));
				
				let sl = document.querySelector('.seedlayer');
				sl.insertBefore(pill, sl.firstChild);
				seedElem.value = '';
			}
		}
	</script>
  </head>
  <body>
<div class="seedouter">
	<div class="seedlayer">
		<input type="text" size="20" name="seedvalue">
		<input type="button" value="add" onclick="addSeed()">
	</div>
</div>

<div class="textlayer"><div class="textglass"></div><ul class="textitems"></ul></div>
<div id="ThreeJS" style="z-index: 10; overflow: hidden;"></div>
<script>

	var container, scene, camera, renderer, controls;
	var textitems = document.querySelector('.textitems');
	
	// SCENE
	scene = new THREE.Scene();
	var raycaster = new THREE.Raycaster();
	raycaster.params.Points.threshold = 128;
	
	var mouse = new THREE.Vector2();
	var lastSelected = undefined;

	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	
	//	draw a red/green/blue grid to show x/y/z axis
	var DRAW_GRID = false;
	
	// how many to spread our the datapoints by which will also impact how big the points are in the graph.
	// if you pick a MAX_XY too small and it either crashes or looks very blocky/rubbish.
	// if you pick something bigger then you will also need to increase POINT_SIZE
	var MAX_XY = 100000;
	var POINT_SIZE = 128;
	
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, -1);
	scene.add(camera);
	
	// the coords-map-large.txt file defines W2VDATA whiich contains our keywords and their co-ordinates.
	var geometry = new THREE.BufferGeometry();
	var points;
	var positions = new Float32Array(W2VDATA.length * 3);
	var colours = new Float32Array(W2VDATA.length * 3);
	
	//	create a lookup table to convert from our group number (generated by the k-means step) and a suitable colour.
	//  the second param to THREE.Lut() should be <= CLUSTERS in w2v.py
	var lut = new THREE.Lut( "rainbow", 20 );
	lut.setMin(0);
	lut.setMax(19);
	
	//	instead of using the lookup table above we can also use the colours below. this is how i started off, the lut above
	//	was something i added later. not convinced about it though hence not removing either code yet.
	var palette = [
		new THREE.Color(0xff0000),
		new THREE.Color(0x00ff00),
		new THREE.Color(0x0000ff),
		new THREE.Color(0xffff00),
		new THREE.Color(0x00ffff),
		new THREE.Color(0xC0C0C0),
		new THREE.Color(0xDAA520),
		new THREE.Color(0x800000),
		new THREE.Color(0x800080),
		new THREE.Color(0xD2691E)
	];
	
	var labelblobgeom = new THREE.SphereBufferGeometry(POINT_SIZE);
	var labelblobmat = new THREE.MeshBasicMaterial( { color: 0xffffff });
	var textlabels = [];
	
	function createTextLabel() {
		//	taken from https://codepen.io/dxinteractive/pen/reNpOR
		var div = document.createElement('div');
		div.className = 'text-label';
		div.style.position = 'absolute';
		div.style.width = 100;
		div.style.height = 100;
		div.innerHTML = "hi there!";
		div.style.top = -1000;
		div.style.left = -1000;
		
		var _this = this;
		
		return {
		  element: div,
		  parent: false,
		  position: new THREE.Vector3(0,0,0),
		  setHTML: function(html) {
			this.element.innerHTML = html;
		  },
		  setParent: function(threejsobj) {
			this.parent = threejsobj;
		  },
		  updatePosition: function() {
			if(parent) {
				let a = points.geometry.getAttribute('position');
			  this.position.fromBufferAttribute(a, this.parent);
			}
			
			var coords2d = this.get2DCoords(this.position, _this.camera);
			this.element.style.left = coords2d.x + 'px';
			this.element.style.top = coords2d.y + 'px';
		  },
		  get2DCoords: function(position, camera) {
			var vector = position.project(camera);
			vector.x = (vector.x + 1)/2 * window.innerWidth;
			vector.y = -(vector.y - 1)/2 * window.innerHeight;
			return vector;
		  }
		};
	  }
	
	function addTextPoint(index) {
		let a = geometry.getAttribute('position');
		let tl = createTextLabel();
		tl.setHTML(W2VDATA[index][0]);
		tl.setParent(index);
		textlabels.push(tl);
		container.appendChild(tl.element);
		
		let tb = new THREE.Mesh(labelblobgeom, labelblobmat);
		tb.position.fromBufferAttribute(a, index);
		scene.add(tb);
	}
	
	(function() {
		//	first normalise our co-ordinates. they're just a bunch of numbers so first let's find the min and max values.
		let min = 999;
		let max = -999;
		
		W2VDATA.forEach((e) => {
			min = Math.min(min, Math.min(Math.min(e[1], e[2]), e[3]));
			max = Math.max(max, Math.max(Math.max(e[1], e[2]), e[3]));
		});
		
		//	and now the actualy co-ordinate we store for each point in the graph will be normalised against this diff
		let diff = max - min;
		
		let ix = 0;
		W2VDATA.forEach((e, i) => {
			let x = (e[1] - min) / diff;
			let y = (e[2] - min) / diff;
			let z = (e[3] - min) / diff;
			let c = palette[e[4]];	// make sure e[4] is < CLUSTERS (in w2v.py)
			//let c = lut.getColor(e[4]);
			
			positions[ix] = x * MAX_XY;
			positions[ix + 1] = y * MAX_XY;
			positions[ix + 2] = z * MAX_XY;
			
			colours[ix] = c.r;
			colours[ix + 1] = c.g;
			colours[ix + 2] = c.b;
			
			ix += 3;
		});
		
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colours, 3 ) );
		geometry.colors = colours;
		geometry.computeBoundingSphere();
		
		geometry.translate(-geometry.boundingSphere.center.x, -geometry.boundingSphere.center.y, -geometry.boundingSphere.center.z);
		
		//	this is why the rendering is so fast, because we're using points. i did try using 3d cubes but it was very slow to render
		//	and anything beyond 50k cubes and my laptop was upset. so...points is the winner.
		let material = new THREE.PointsMaterial( { size: POINT_SIZE, vertexColors: THREE.VertexColors } );
		points = new THREE.Points( geometry, material );
		scene.add( points );
		
		camera.position.set(0, geometry.boundingSphere.radius, geometry.boundingSphere.radius);
		camera.lookAt(geometry.boundingSphere.center);
	})();
	
	renderer = new THREE.WebGLRenderer( {antialias:false} );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	window.addEventListener( 'resize', () => {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}, false );	
	
	//	if you enable the grid you'll notice the origin is the center of the sphere that contains the points, not the weighted
	//	centre of the points. (ie. it looks off)
	DRAW_GRID && (function() {
		var gridXZ = new THREE.GridHelper(MAX_XY, 10, new THREE.Color(0x006600), new THREE.Color(0x006600));
		gridXZ.position.set( MAX_XY / 2, 0, MAX_XY / 2 );
		scene.add(gridXZ);
		
		var gridXY = new THREE.GridHelper(MAX_XY, 10, new THREE.Color(0x000066), new THREE.Color(0x000066));
		gridXY.position.set( MAX_XY / 2, MAX_XY / 2, 0 );
		gridXY.rotation.x = Math.PI / 2;
		scene.add(gridXY);

		var gridYZ = new THREE.GridHelper(MAX_XY, 10, new THREE.Color(0x660000), new THREE.Color(0x660000));
		gridYZ.position.set( 0, MAX_XY / 2, MAX_XY / 2 );
		gridYZ.rotation.z = Math.PI / 2;
		scene.add(gridYZ);
	})();
	
	container.addEventListener('keypress', (evt) => {
		if (evt.key === 'w') {
			camera.translateZ(-MAX_XY / 1);
			render();		
		update();
		} else if (evt.key === 's') {
			camera.translateZ(MAX_XY / 1);
			render();		
		update();
		} else if (evt.key === 'a') {
			camera.translateX(-MAX_XY / 1);
			render();		
		update();
		} else if (evt.key === 'd') {
			camera.translateX(MAX_XY / 1);
			render();		
		update();
		}
	});
	
	//	we track what's under the mouse and put a white sphere over that data point (keyword).
	//	if you click then the sphere sticks, if you click empty space then the sphere unsticks.
	//	if the sphere isn't sticky then the keyword is printed to the developer console.
	var myBall;
	var lastSelected = -1;
	var picked = false;

	(function() {
		let geom = new THREE.SphereBufferGeometry(POINT_SIZE);
		let mat = new THREE.MeshBasicMaterial( { color: 0xffffff });
		myBall = new THREE.Mesh(geom, mat);
		
		myBall.position.set(positions[0], positions[1], positions[2]);
		
		scene.add(myBall);
	})();
	
	function onMouseDown(event) {
	console.log('onmousedown');
		event.preventDefault();
		
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		
		raycaster.setFromCamera( mouse, camera );
		
		let hits = raycaster.intersectObject(points);
		if (hits.length) {
			let hit = hits[0];
			let a = geometry.getAttribute('position');
			myBall.position.fromBufferAttribute(a, hit.index);
			lastSelected = hit.index;
			
			console.log(W2VDATA[hit.index][0]);
			
			picked = true;
			
			addTextPoint(hit.index);
			//controls.reset();
			camera.lookAt(myBall.position);
			controls.target = myBall.position.clone();
			//controls.saveState();
		} else {
			//controls.reset();
			camera.lookAt(geometry.boundingSphere.center);
			controls.target = geometry.boundingSphere.center.clone();
			//controls.saveState();
			myBall.position.set(camera.position.x, camera.position.y, camera.position.z);
			lastSelected = -1;
			picked = false;
		}
	}
	
	function onMouseMove( event ) {
		// calculate mouse position in normalized device coordinates
		// (-1 to +1) for both components

		if (event.buttons) return;
		
		event.preventDefault();
		
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		
		if (picked) return;
		
		raycaster.setFromCamera( mouse, camera );
		
		let hits = raycaster.intersectObject(points);
		if (hits.length) {
			let hit = hits[0];
			
			if (lastSelected == hit.index) return;
			
			let ix = hit.index * 3;
			
			//	if you want to change the colour of the data point under the mouse then do the following
			//let a = hit.object.geometry.getAttribute('color');
			//a.set(plopsy, ix);
			//a.needsUpdate = true;
			
			let a = hit.object.geometry.getAttribute('position');
			//myBall.position.set(a.array[ix], a.array[ix + 1], a.array[ix + 2]);
			myBall.position.fromBufferAttribute(a, hit.index);
			lastSelected = hit.index;
			
			let li = document.createElement('li');
			li.innerText = W2VDATA[hit.index][0];
			textitems.appendChild(li);
			if (textitems.children.length > 20) {
				textitems.removeChild(textitems.firstChild);
			}
		} else {
			myBall.position.set(camera.position.x, camera.position.y, camera.position.z);
			lastSelected = -1;
		}
	}
	
	function animate() 
	{
		requestAnimationFrame( animate );
		render();		
		update();
	}

	function update()
	{
		controls.update();
	}

	function render() 
	{
		textlabels.forEach((e) => {
			e.updatePosition();
		});
		renderer.render( scene, camera );
	}
	
	animate();
	container.addEventListener( 'mousedown', onMouseDown, false );
	container.addEventListener( 'mousemove', onMouseMove, false );

</script>
</body>
</html>
